# RV32I CPU - 最小シミュレーション

## これについて
このリポジトリは、Verilog で実装された小規模な RV32I（RISC-V 32ビット）CPU の例です。  
1つのファイルにまとまったコア（`rv32i.v`）と、単純なメモリモデル、レジスタファイル、ALU、そして32ビットワードをレジスタ x1 にロードする小さなプログラムを実行するテストベンチを含む。

---

## 注目すべきファイル
- `rv32i.v` - CPUコア（フェッチ／デコード／実行／メモリ／ライトバックのパイプラインを1つのモジュールで実装）
- `reg.v` - コアで使用されるレジスタファイル（`rfile`）モジュール
- `alu.v` - コアで使用される単純な ALU
- `i_mem.v` - 命令メモリ（元の記事と違って、バイト配列をリトルエンディアンの32ビットワードに構成した）
- `d_mem.v` - データメモリ（バイト／ハーフ／ワード単位のストアに対応）
- `defines.v` - CPUで使用される opcode / funct3 定義
- `tb_rv32i.v` - CPU＋メモリをインスタンス化し、クロック／リセットを駆動し、実行前後のメモリダンプを書き出し、小規模テストとアサーションを行うテストベンチ
- `mem.bin` - 小さなテストプログラムの命令メモリ初期化ファイル
- `data_mem.dat` - データメモリ初期化ファイル（例で使用されるワード 0xDEADBEEF を含む）

---

## テストの内容
テストベンチは短いシミュレーションを実行します。  
このシミュレーションでは、CPU がメモリアドレス 0 にある 32ビットワードをレジスタ x1 にロードする `lw` 命令をフェッチします。  
テストは自動的に x1 が 0xDEADBEEF に等しいか確認し、**PASS** または **FAIL** を出力します。  
シミュレーション中に以下のファイルも出力されます：

- `reg_before.mem`, `reg_after.mem` - テスト前後のレジスタファイル  
- `data_before.mem`, `data_after.mem` - テスト前後のデータメモリ  
- `sim.vcd` - GTKWave で確認するための波形ファイル

---

## 前提条件
- Icarus Verilog（`iverilog`, `vvp`）がインストールされていること。  
  使用したのはWindows の MSYS2/MinGW64 環境では `pacman` でインストールした Icarus Verilog。  

---

## クイックビルド＆実行（MSYS2 / MinGW64 推奨）

```bash
cd /e/Sotsuken
iverilog -o sim.vvp tb_rv32i.v rv32i.v i_mem.v d_mem.v reg.v alu.v defines.v
vvp sim.vvp
